
import QtQuick 1.1
import "." 1.0

Item {
    id: root

    width: parent ? parent.width : 0
    height: parent ? parent.height : 0

    property int depth: privates.stackDepth()
    property Item currentPage: null
    property Item toolBar
    property bool busy: privates.ongoingTransitionCount > 0

    Component.onCompleted: {pageStack = []}
    property variant pageStack

    QtObject {
        id: privates
        property int ongoingTransitionCount: 0

        function stackDepth()
        {
            return (pageStack !== undefined) ? pageStack.length : 0
        }

        function initializePage(page, properties)
        {
            var component = containerComponent.createObject(root)
            var pgComponent;
            if (page.createObject != undefined) {
                pgComponent = page
            } else if (typeof page == "string") {
                pgComponent = Qt.createComponent(page)
            }
            if (pgComponent) {
                if (pgComponent.status == Component.Error)
                    throw new Error("Error while loading page: " + pageComp.errorString());
                else {
                    page = pgComponent.createObject(component, properties || {})
                }
            }
            else
                throw new Error("Unknown page given:" + page);

            component.page = page;
            component.owner = page.parent;

            // the page has to be reparented if
            if (page.parent != component) {
                page.parent = component;
            }

            if (page.pageStack !== undefined) {
                page.pageStack = root;
            }

            return component;
        }

        function push(page, properties)
        {
            if (page == currentPage)
                throw new Error("Cannot push current page twice!")
            var oldContainer = pageStack[pageStack.length - 1]

            var container = initializePage(page, properties)

            pageStack.push(container)

            depth = pageStack.length
            currentPage = container.page
            console.debug("push: old="+oldContainer)
            console.debug("push: depth="+depth)
            console.debug("push: current="+container.page)
            if (oldContainer)
                oldContainer.pushExit()
            container.pushEnter()
            return container.page
        }

        function pop(page)
        {
            if (pageStack.length < 1)
                return null

            var oldContainer = pageStack.pop()
            var container = pageStack[pageStack.length - 1]
            if (page !== undefined) {
                // page has been spoecified, unwind till we get it
                while ((page != container.page) && (pgStack.length > 1)) {
                    container.cleanup();
                    pageStack.pop();
                    container = pageStack[pageStack.length - 1];
                }
            }
            depth = pageStack.length
            currentPage = container.page
            oldContainer.popExit()
            container.popEnter()
            return oldContainer.page
        }

        function clearStack()
        {
            var container;
            while (container = pageStack.pop()) {
                container.cleanup();
            }
            depth = 0;
            currentPage = null;
        }
    }

    function push(page, properties) {
        return privates.push(page, properties)
    }

    function pop(page) {
        return privates.pop(page)
    }
    function back()
    {
        if (pageStack.length > 1)
            return pop()
    }

    function clear() {
        return privates.clear();
    }

    /*
    function find(func) {
        return Engine.find(func);
    }
    */
    
    // Called when the page stack visibility changes.
    onVisibleChanged: {
        if (currentPage) {
            __setPageStatus(currentPage, visible ? WidgetSet.PageActive : WidgetSet.PageInactive);
            if (visible) {
                currentPage.visible = currentPage.parent.visible = true;
            }
        }
    }

    // Sets the page status.
    function __setPageStatus(page, status) {
        if (page.status !== undefined) {
            if (status == WidgetSet.PageActive && page.status == WidgetSet.PageInactive) {
                page.status = WidgetSet.PageActivating;
            } else if (status == WidgetSet.PageInactive && page.status == WidgetSet.PageActive) {
                page.status = WidgetSet.PageDeactivating;
            }
            page.status = status;
        }
    }

    // Page container - hold pages created upon push operations
    Component {
        id: containerComponent

        Item {
            id: container

            width: parent ? parent.width : 0
            height: parent ? parent.height : 0

            // The states correspond to the different possible positions of the container.
            state: "hidden"

            // The page held by this container.
            property Item page: null
            
            // The owner of the page.
            property Item owner: null

            // Flag that indicates the container should be cleaned up after the transition has ended.
            property bool cleanupAfterTransition: false

            // Performs a push enter transition.
            function pushEnter() {
                // enter from right side, then reset
                state = 'right'
                state = '';
                // make page visible
                page.visible = true;
            }

            // Performs a push exit transition.
            function pushExit() {
                // fade out to left then reset
                console.debug("pushExit: " + page + ", state= " + state)
                state = "left";
                console.debug("pushExit: " + page + ", state= " + state)
            }

            // Performs a pop enter transition.
            function popEnter(immediate) {
                state = "left";
                state = "";
                page.visible = true;
            }

            // Performs a pop exit transition.
            function popExit(immediate) {
                state = "right";
                cleanupAfterTransition = true;
            }
            
            // Called when a transition has started.
            function transitionStarted() {
                privates.ongoingTransitionCount++;
                if (root.visible) {
                    __setPageStatus(page, (state == "") ? WidgetSet.PageActivating : WidgetSet.PageDeactivating);
                }
            }
            
            // Called when a transition has ended.
            function transitionEnded() {
                if (state != "") {
                    state = "hidden";
                }
                if (root.visible) {
                    __setPageStatus(page, (state == "") ? WidgetSet.PageActive : WidgetSet.PageInactive);
                }
                privates.ongoingTransitionCount--;
                if (cleanupAfterTransition) {
                    cleanup();
                }
            }

            states: [
                // Explicit properties for default state.
                State {
                    name: ""
                    PropertyChanges { target: container; visible: true }
                },
                // Start state for pop entry, end state for push exit.
                State {
                    name: "left"
                    PropertyChanges { target: container; x: -width }
                },
                // Start state for push entry, end state for pop exit.
                State {
                    name: "right"
                    PropertyChanges { target: container; x: width }
                },
                // Inactive state.
                State {
                    name: "hidden"
                    PropertyChanges { target: container; visible: false }
                }
            ]

            transitions: [
                // Pop entry and push exit transition.
                Transition {
                    from: ""; to: "left"; reversible: true
                    SequentialAnimation {
                        ScriptAction { script: if (state == "left") { transitionStarted(); } else { transitionEnded(); } }
                        PropertyAnimation { properties: "x"; easing.type: Easing.InOutExpo; duration: UI.pageFadingDuration }
                        ScriptAction { script: if (state == "left") { transitionEnded(); } else { transitionStarted(); } }
                    }
                },
                // Push entry and pop exit transition.
                Transition {
                    from: ""; to: "right"; reversible: true
                    SequentialAnimation {
                        ScriptAction { script: if (state == "right") { transitionStarted(); } else { transitionEnded(); } }
                        PropertyAnimation { properties: "x"; easing.type: Easing.InOutExpo; duration: UI.pageFadingDuration }
                        ScriptAction { script: if (state == "right") { transitionEnded(); } else { transitionStarted(); } }
                    }
                }
            ]
            
            // Cleans up the container and then destroys it.
            function cleanup() {
                console.debug("cleaup container: " + container.page)
                if (page.status == WidgetSet.PageActive) {
                    __setPageStatus(page, WidgetSet.PageInactive);
                }
                if (owner != container) {
                    // container is not the owner of the page - re-parent back to original owner
                    page.visible = false;
                    page.parent = owner;
                }
                container.destroy();
            }

        }
    }

}

