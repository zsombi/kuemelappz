#include "globaldefs.h"
#include "applicationitem.h"
#include "applicationitem_p.h"
#include "widgetset.h"
#include <QApplication>
#include <QDeclarativeView>

#ifdef MOBILE_SYSTEM
#include <QOrientationSensor>
#include <QOrientationReading>
QTM_USE_NAMESPACE
#endif

#ifdef Q_OS_SYMBIAN
#include <eikenv.h>
#include <eikappui.h>
#include <aknenv.h>
#include <aknappui.h>
#endif

ApplicationItemPrivate::ApplicationItemPrivate(ApplicationItem *qq) :
    q_ptr(qq),
    orientation(ApplicationItem::Automatic),
    orientationLocked(false),
    sensor(0),
    screenSize(0,0),
    appView(0)
{
    WidgetSet::instance()->appWindow = q_ptr;
#ifdef Q_OS_SYMBIAN
    //QCoreApplication::setAttribute(Qt::AA_S60DontConstructApplicationPanes);
#endif
    foreach (QWidget *w, QApplication::allWidgets()) {
        appView = qobject_cast<QDeclarativeView*>(w);
        if (appView) {
#ifdef Q_OS_SYMBIAN
            CAknAppUi* appUi = dynamic_cast<CAknAppUi*> (CEikonEnv::Static()->AppUi());
            TRAPD(error,
                if (appUi)
                    appUi->SetOrientationL(CAknAppUi::EAppUiOrientationPortrait);
            );
            Q_UNUSED(error)
#endif
            appView->setAttribute(Qt::WA_LockPortraitOrientation);
            q_ptr->connect(appView, SIGNAL(sceneResized(QSize)), SLOT(_q_sceneUpdate(const QSize&)), Qt::QueuedConnection);
            appView->setResizeMode(QDeclarativeView::SizeRootObjectToView);
            break;
        }
    }
#ifdef MOBILE_SYSTEM
    sensor = new QOrientationSensor(q_ptr);
    q_ptr->connect(sensor, SIGNAL(readingChanged()), SLOT(_q_sensorUpdate()));
    qobject_cast<QOrientationSensor*>(sensor)->setActive(true);
#else
    orientation = ApplicationItem::Portrait;
#endif
}

ApplicationItem::ApplicationItem(QDeclarativeItem *parent) :
    StyledItem(parent),
    d_ptr(new ApplicationItemPrivate(this))
{
}

ApplicationItem::~ApplicationItem()
{

}

ApplicationItem::Orientation ApplicationItem::orientation() const
{
    Q_D(const ApplicationItem);
    return d->orientation;
}
QString ApplicationItem::orientationString() const
{
    Q_D(const ApplicationItem);
    if (d->orientation == ApplicationItem::Automatic)
        return QString();
    int index = metaObject()->indexOfEnumerator("Orientation");
    Q_ASSERT(index != -1);
    QMetaEnum enumerator = metaObject()->enumerator(index);
    return QLatin1String(enumerator.valueToKey(d->orientation));
}
ApplicationItem::Orientation ApplicationItem::lockToOrientation() const
{
    Q_D(const ApplicationItem);
    return d->orientation;
}
void ApplicationItem::setLockToOrientation(Orientation o)
{
#ifdef MOBILE_SYSTEM
    Q_D(ApplicationItem);
    bool lock = (o == ApplicationItem::Automatic);

    if (lock != d->orientationLocked) {
        d->orientationLocked = lock;
        if (lock)
            d->orientation = o;
        qobject_cast<QOrientationSensor*>(d->sensor)->setActive(!lock);
        d->setOrientation(o);
    }
#endif
}

QDeclarativeItem *ApplicationItem::inputPanel() const
{
    Q_D(const ApplicationItem);
    return d->inputPanel;
}
void ApplicationItem::setInputPanel(QDeclarativeItem *ip)
{
    Q_D(ApplicationItem);
    if (d->inputPanel != ip) {
        d->inputPanel = ip;
        emit inputPanelChanged();
    }
}


//**************************************************************

void ApplicationItemPrivate::_q_sceneUpdate(const QSize &sceneSize)
{
    Q_Q(ApplicationItem);
    if (sceneSize != screenSize) {
        // set property to invoke property binding
        resize(sceneSize, q->property("rotation").toInt());
    }
}

void ApplicationItemPrivate::_q_sensorUpdate()
{
    if (orientationLocked)
        return;
#ifdef MOBILE_SYSTEM
    QOrientationReading *reading = qobject_cast<QOrientationSensor*>(sensor)->reading();
    ApplicationItem::Orientation o = orientation;
    switch (reading->orientation()) {
    case QOrientationReading::LeftUp:
        o = ApplicationItem::InverseLandscape;
        break;
    case QOrientationReading::RightUp:
        o = ApplicationItem::Landscape;
        break;
    default:
        o = ApplicationItem::Portrait;
        break;
    }
    setOrientation(o);
#endif
}

void ApplicationItemPrivate::resize(const QSize &size, int rotation)
{
    Q_Q(ApplicationItem);
    screenSize = size;
    q->setProperty("width", screenSize.width());
    q->setProperty("height", screenSize.height());
}

void ApplicationItemPrivate::setOrientation(ApplicationItem::Orientation o)
{
    Q_Q(ApplicationItem);

    if (this->orientation != o) {
        orientation = o;
        // adjust screen size

        int shortEdge = qMin(screenSize.width(), screenSize.height());
        int longEdge = qMax(screenSize.width(), screenSize.height());
        QSize newSize(shortEdge, longEdge);
        if (orientation == ApplicationItem::Landscape || orientation == ApplicationItem::InverseLandscape) {
            newSize.transpose();
        }

        // set item rotation
        switch (o) {
        case ApplicationItem::InverseLandscape:
            q->setProperty("rotation", 270);
            break;
        case ApplicationItem::Landscape:
            q->setProperty("rotation", 90);
            break;
        default:
            q->setProperty("rotation", 0);
            break;
        }
        resize(newSize, q->property("rotation").toInt());

        emit q->orientationChanged();
    }
}

#include "moc_applicationitem.cpp"
